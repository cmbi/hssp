//          Copyright Maarten L. Hekkelman 2006-2010
// Distributed under the Boost Software License, Version 1.0.
//    (See accompanying file LICENSE_1_0.txt or copy at
//          http://www.boost.org/LICENSE_1_0.txt)

#ifndef MRSRC_H
#define MRSRC_H

#include <string>
#include <list>
#include <exception>

/*
	Resources are data sources for the application.
	
	They are retrieved by name.

	Basic usage:
	
	mrsrc::rsrc rsrc("dialogs/my-cool-dialog.glade");
	
	if (rsrc)
	{
		GladeXML* glade = glade_xml_new_from_buffer(rsrc.data(), rsrc.size(), NULL, "japi");
		
		...
	}
*/

namespace mrsrc {
	struct rsrc_imp
	{
		unsigned int	m_next;
		unsigned int	m_child;
		unsigned int	m_name;
		unsigned int	m_size;
		unsigned int	m_data;
	};
}

// The following three variables are generated by the japi resource compiler:

extern const mrsrc::rsrc_imp	gResourceIndex[];
extern const char				gResourceData[];
extern const char				gResourceName[];

namespace mrsrc
{

class rsrc_not_found_exception : public std::exception
{
  public:
    virtual const char* what() const throw()		{ return "resource not found"; }
};

class rsrc;
typedef std::list<rsrc>	rsrc_list;

class rsrc
{
  public:
						rsrc() : m_impl(gResourceIndex) {}

						rsrc(
							const rsrc&			other)
							: m_impl(other.m_impl) {}

	rsrc&				operator=(
							const rsrc&			other)
						{
							m_impl = other.m_impl;
							return *this;
						}
	
						rsrc(
							const std::string&	path);

	std::string			name() const			{ return gResourceName + m_impl->m_name; }

	const char*			data() const			{ return gResourceData + m_impl->m_data; }
	
	unsigned long		size() const			{ return m_impl->m_size; }

						operator bool () const	{ return m_impl != NULL and m_impl->m_size > 0; }

	rsrc_list			children() const;

  private:

						rsrc(
							const rsrc_imp*		imp)
							: m_impl(imp) {}

	const rsrc_imp*		m_impl;
};

inline
rsrc_list rsrc::children() const
{
	rsrc_list result;
	
	if (m_impl->m_child)
	{
		const rsrc_imp* impl = gResourceIndex + m_impl->m_child;
		result.push_back(rsrc(impl));
		while (impl->m_next)
		{
			impl = gResourceIndex + impl->m_next;
			result.push_back(rsrc(impl));
		}
	}
	
	return result;
}

inline
rsrc::rsrc(
	const std::string&		path)
{
//	static_assert(sizeof(m_impl->m_next) == 4, "invalid size for unsigned int");
	
	m_impl = gResourceIndex;
	
	std::string p(path);
	
	// would love to use boost functions here, but then the dependancies
	// should be minimal of course.
	while (not p.empty())
	{
		if (m_impl->m_child == 0)	// no children, this is an error
			throw rsrc_not_found_exception();

		m_impl = gResourceIndex + m_impl->m_child;
		
		std::string::size_type s = p.find('/');
		std::string name;
		
		if (s != std::string::npos)
		{
			name = p.substr(0, s);
			p.erase(0, s + 1);
		}
		else
			std::swap(name, p);
		
		while (name != gResourceName + m_impl->m_name)
		{
			if (m_impl->m_next == 0)
				throw rsrc_not_found_exception();
			m_impl = gResourceIndex + m_impl->m_next;
		}
	}
}

}

#endif
